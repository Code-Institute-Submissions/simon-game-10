# Logic used to build the game
I wrote the code for this game by going through the motions as a player to see what they would expect to see or to happen at each stage.<br>
Below is a step by step explanation of my process of building the game logic.<br>
With a separate section for user interface elements underneath the game logic where applicable.<br>

It was apparent that there were going to be certain variables that would change thoughout the game. I decided to store these in a game object called gameData.
The basic variables I considered initially are as follows:
<pre><code>
var gameData = {
    count : 0, // the count would be to keep track of the number of rounds
    gameSequence : [], // the sequence generated by the game would go into an array
    playerSequence : [], // the sequence inputted by the player would go into an array
    powerStatus : false, // player can turn game ON and OFF so a powerStatus has to be recorded
    startStatus : false, // player can press start button so a status to record the startStatus is required
    strictStatus: false, // the game will have a strict mode which is either ON or OFF, the game needs to know which.
};
</code></pre>

## The player turns the game ON (i.e presses the power button)
The power button has to change state when clicked.
The player has to see this change somehow.
#### Game Logic
1) The power button is in OFF state (i.e false) when page is first opened.
<br> When running these tests I un-checked the 'run tests in random order' option in Jasmine.
This is because if the "Initial power status" spec is run after the "power status change to ON" then
the test doesn't pass (as it may see the initial value as 'true' if some of the other tests have run before it).
I did try to mitigate this by using the 'location.reload()' function however this caused my jasmine application
to continuously reload the page and crash.

I gave powerStatus a default value of false so the game is OFF when the page first loads.
<pre><code>var gameData = {
    powerStatus : false,
    }
  </code></pre>


2) The power button changes to ON state (i.e true) when in OFF state and button is clicked.
3) The power button changes to OFF state (i.e false) when in ON state and button is clicked.<br>

Then I had to 'grab' my power button (using its ID which I set to 'power' ) and get it to change status when clicked.
    <pre><code>document.getElementById('power').onclick = function() {
            gameData.powerStatus = !gameData.powerStatus;
    };</pre></code>
    
4) The player chooses whether to play in strict mode
When the game is in strict mode, as soon as the player gets a sequence wrong the game re-starts.
I gave strictStatus (the variable that tracks whether strictmode is ON or OFF) a default value of false so it is OFF when the page loads.
The game needs to know if this status changes so I added an event listener on the strict button to listen for a click, and 
added code to change the strictStatus if that button was clicked:
<pre><code>
document.getElementById('strict').onclick = function() {
    gameData.strictStatus = !gameData.strictStatus; // This changes the strict status when clicked and can be clicked at any point in the game
};
</code></pre>
   
#### User Interface
1) The game display should show 'Ready' when power is ON (i.e powerStatus is true).
2) The game display should show '' (i.e. nothing) when power is OFF (powerstatus = false).

First I had to add an event listener to recognise when the power button was pressed.<br>
Then I had to check if power was ON or OFF.<br>
Then I had to grab the display div by id ('display') and change its inner content:
<pre><code> document.getElementById('power').addEventListener('click', function() { //event listener
    if (gameData.powerStatus === true) {
        document.getElementById('display').innerHTML = "Ready"; //power is ON
    }
    else {
        document.getElementById('display').innerHTML = ''; // power is OFF
    }
});</code></pre>

3) There needs to be a visual indicator that the game is in strict mode






## The player clicks the start button
The start button has to change state when clicked.
#### Game Logic
1) The start button is in OFF state (i.e false) when page is first opened.

I also set the startStatus to an inital value of false as I didn't want the game to start as soon as the page was loaded:
<pre><code>var gameData = {
    powerStatus : false,
    startStatus : false
    }
  </code></pre>

2) The start button changes to ON state (i.e true) when in OFF state when the button is clicked.
3) The start button changes to OFF state (i.e false) when in ON state when the button is clicked.

Then I created a function that changed between ON and OFF (i.e true and false) when the start button was clicked (similar to power button).<br>
<pre><code>document.getElementById('start').onclick = function() { // event listener listening for start button click
    gameData.startStatus = !gameData.startStatus; // toggles between true and false
    }
};</code></pre>

4) The start button changes to OFF state (i.e false) regardless of starting state if the power button goes to OFF state.

To get the start status to change to OFF (false) when power was clicked off I had to add a conditional to my power onclick function.<br>
<pre><code>document.getElementById('power').onclick = function() {
    gameData.powerStatus = !gameData.powerStatus;
    if (gameData.powerStatus === false) { // conditional checks whether power is off 
        gameData.startStatus = false; // whenever power is turned OFF, startStatus will return to default OFF (i.e false)
    }
};
</code></pre>

Initially, as you can see above, I wanted the start button to change state every time it was clicked. 
However, while doing some manual tests I realised this was causing unnecessary work for the player 
-if they pressed start before power, then pressed power, they had to click start another two times to get the game to start.<br>
To fix this I changed the above logic like so:
1) The start button is in OFF state (i.e false) when page is first opened.
2) The start button changes to ON state (i.e true) when in OFF state ONLY if power is already in ON state when start button is clicked.
3) The start button changes to OFF state (i.e false) if the power button goes to OFF state.<br>
I changed my start onclick function so it only triggered a change of state from false to true IF power state was also true:
<pre><code>document.getElementById('start').onclick = function() {
    if (gameData.powerStatus === true && gameData.startStatus === false) { //conditional so startStatus will ONLY change if powerStatus is true (i.e ON)
        gameData.startStatus = !gameData.startStatus; // changes startStatus to true
    }
};</code></pre>

## The game starts
The game must only start if the power is ON and the start button is ON. 
(i.e powerStatus and startStatus are BOTH true, having been clicked.)
The player needs to see this change somehow to indicate game has started and to see what round they are on.
#### Game Logic
1) When start status is true AND power status is true newGame() function is called.
2) When start status is false and power status is true newGame() function is NOT called.
3) When start status is false and power status is false newGame() function is NOT called.
Due to earlier tests in start button suite it is impossible to have a start status of true while power status is
false so that is not included here.<br>
I needed to create a function that would start the game for the player. I called this function newGame and called it in my start onclick function.
This meant when power was ON, start had been clicked, newGame would be called.
<pre><code>document.getElementById('start').onclick = function() { // listening for click of start button
    if (gameData.powerStatus === true && gameData.startStatus === false) { 
        gameData.startStatus = !gameData.startStatus; // changing start to true
        newGame(); // this function called here
    }
};</code></pre>

#### User Interface
1) The player needs to see the game has started.
To achieve this I decided to display the round number (the count) in the display. From earlier, the display is showing the 'Ready' message as the power is ON.
Now I wanted to show a number indicating the first round was now starting.

I created a 'displayCount()' UI function that grabs the display element and changes its innerHTML to the count and called it within the start onclick function like so:
<pre><code>function displayCount() {
        document.getElementById('display').innerHTML = gameData.count;
}

document.getElementById('start').onclick = function() {
    if (gameData.powerStatus === true && gameData.startStatus === false) {
        gameData.startStatus = !gameData.startStatus; 
        newGame(); 
        displayCount(); // called here
    }
};
</code></pre>

I came across a problem here because although the count was displaying, it was displaying 0 when I wanted the count to be 1. 
So I incremented the count in the newGame function, now the count would go to 1 before displayCount was called:

<pre><code>
function newGame(){
    gameData.count++; //incremented - this is executed before displayCount is called in start onclick function above
}
</code></pre>

## New game parameters are set for first round and newRound() function is called.
Some of the gameData values need to be set for the start of a new game.
While working through the logic, I realised there would be three instances when a new game would be started.
First when the player first turns on the machine and starts game for the first time, second when the player wins and
third when the player gets it wrong in strict mode. Therefore, it wasn't feasible to have the game parameters reset within the start onclick function
because this is not always what would trigger a new game.
These are the parameters to reset: gameSequence and playerSequence. 

#### Game Logic
1) When newGame() function is called certain game parameters are reset.
2) When newGame() function is called, it calls newRound() function.

In my newGame function I reset these parameters to their initial values.
I also called a new function named newRound - this will will be called in each successive round.
<pre><code>
function newGame() {
    gameData.count++;
    gameData.gameSequence = [];
    gameData.playerSequence = [];
    newRound();
}
</code></pre>

## newRound() function calls three functions to enable the game to progress
These three functions are: generateSequence(), showSequence() and playerInput().
The game needs to do three things now, it needs to create a sequence, show it to the player and record the player's input.

#### Game Logic
1) When newRound() function is called generateSequence() function is called
2) When newRound() function is called showSequence() function is called
3) When newRound() function is called playerInput() function is called

Here, newRound just calls these three functions like so:
<pre><code>
function newRound() {
    generateSequence();
    showSequence();
    playerInput();
}
</code></pre>


## generateSequence() function generates a sequence for the game to use
This sequence should be a random sequence consisting of the numbers 1,2,3 or 4.<br>
This sequence should be pushed into an array defined in the gameData object, called 'gameSequence'.<br>
Its length should equal gameData.count at the time it is called.

#### Game Logic
1) When generateSequence() function is executed, a sequence is generated and pushed into gameSequence array.
2) That array consists of 1,2,3 or 4 only (no other numbers/characters/strings).

<pre><code>
function generateSequence() {
    gameData.gameSequence.push(Math.floor(Math.random() * 4 + 1)); // a single random number between 1-4 is added to gameSequence.
}
</code></pre>

3) That array's length is equal to gameData.count

While testing the array's length was equal to gameData.count I came across an issue,
which was that the count had already been incremented in the newGame function so the test would not pass.
I realised this also meant the count would never reset if multiple games were played.

I decided to increment the count when a new number had been added to the gameSequence instead.
(i.e. when generateSequence() function is called instead of in newGame function). I could then reset the count variable in the newGame function to 0. <br>

<pre><code>
function generateSequence() {
    gameData.gameSequence.push(Math.floor(Math.random() * 4 + 1)); 
    gameData.count++; // game count incremented here
    displayCount(); // count displayed
}

function newGame() {
    gameData.count = 0; // could reset to 0 so if multiple games played, no issues.
    gameData.gameSequence = [];
    gameData.playerSequence = [];
    newRound();
}
</code></pre>

#### User Interface
The display should show gameData.count throughout the game and change when the count changes.<br>
1) Display should show gameData.count when the count changes.

This meant the displayCount function also had to be moved to the generateSequence - so every time the count goes up, displayCount is called and 
the current count is called (see above code snippet).


## The gameSequence is displayed to the player
Once the gameSequence has been generated it will be shown to the player as a series of 'flashing' coloured lights and sounds.<br>
The coloured squares will need to have a 'light' class to indicate a change in colour.<br>
This 'light' class will need to be added to and removed from the coloured squares over a short period of time to indicate 'flashing'.<br>
The accompanying sound (relative to each colour) will have to play for the same amount of time.<br>
#### Game logic
1) Game needs to link each number in the gameSequence to a specific coloured square<br>
i.e 1 = red, 2 = yellow, 3 = green, 4 = blue.

The game had to go through the gameSequence one by one so a loop had to be used.
I found it easier to split this logic into two functions. One that would loop through the gameSequence and one that would determine the outcome of each iteration.
<pre><code>
function showSequence() {
    for {var i = 0; i < gameSequence.length; i++} // this function loops through the gameSequence array
        displaySequence(i); // each iteration calls the displaySequence function below
}

function displaySequence(i) { // this function determines the outcome of each iteration depending on what number i is
    if (gameData.gameSequence[i] === 1) {
        // something happens
    }
    else if (gameData.gameSequence[i] === 2) {
        //something happens
    }
    else if (gameData.gameSequence[i] === 3) {
        //something happens
    }
    else {
        //something happens
    }
}
</code></pre>

2) Game needs to call the function that 'lights up' that coloured square and 'sounds' that square's noise 

The light classes need to be added and removed onto the coloured buttons when each one is identified by the displaySequence function.
The sound assigned to each colour also needs to be played.
I created four functions (one for each colour) as below, which are expanded on in the user interface section below:
<pre><code>
function displaySequence(i) { // this function determines the outcome of each iteration depending on what number i is
    if (gameData.gameSequence[i] === 1) {
        red();
    }
    else if (gameData.gameSequence[i] === 2) {
        yellow();
    }
    else if (gameData.gameSequence[i] === 3) {
        green();
    }
    else {
        blue();
    }
}
</code></pre>

3) Game needs to move to the next item in the gameSequence array and trigger that colour function until the array is finished.
The showSequence loop above takes care of this.


#### User Interface
1) Light class needs to be added to coloured square
First I had to create the light classes in my style.css document with background colours that were lighter than the default colours of the buttons.
<pre><code>
.red-light {
    background-color: #ff7f7f;
}

.yellow-light {
    background-color: #ffef99;
}

.green-light {
    background-color: #7fbf7f;
}

.blue-light {
    background-color: #6666ef;
}
</code></pre>

2) Sound needs to be played for relevant coloured square 

I added four sounds to my assets and also added these into the game object like so: 
<pre><code>
var gameData = {
    count : 0,
    gameSequence : [],
    playerSequence : [],
    powerStatus : false,
    startStatus : false,
    strictStatus: false,
    redAudio: redAudio,
    yellowAudio : yellowAudio,
    greenAudio : greenAudio,
    blueAudio : blueAudio
};

var redAudio = new Audio('assets/sounds/simonSound1.mp3');
var yellowAudio = new Audio('assets/sounds/simonSound2.mp3');
var greenAudio = new Audio('assets/sounds/simonSound3.mp3');
var blueAudio = new Audio('assets/sounds/simonSound4.mp3');
</code></pre>
I had to define them first as the play method would not work if they were defined within the game object.

3) Light class needs to be removed after interval of time
4) There needs to be an interval between each colour in sequence flashing (i.e they go one after the other if sequence is longer than 1 item).
I had to 'grab' the coloured button by the ID (1,2,3 and 4 respectively) and apply the appropriate light colour class and play the sound.
To create the illusion of flashing I had to use the setTimeout method within my colour functions otherwise the add and remove class would happen simultaneously with no visual change for the player. 
I set a timeout on the remove class accordingly.
<pre><code>
function red() {
    $(document.getElementById('1')).addClass('red-light');
    gameData.redAudio.play();
    setTimeout(function() {
        $(document.getElementById('1')).removeClass('red-light');
    }, 500);
}

function yellow() {
    $(document.getElementById('2')).addClass('yellow-light');
    gameData.yellowAudio.play();
    setTimeout(function() {
        $(document.getElementById('2')).removeClass('yellow-light');
    }, 500);
}

function green() {
    $(document.getElementById('3')).addClass('green-light');
    gameData.greenAudio.play();
    setTimeout(function() {
        $(document.getElementById('3')).removeClass('green-light');
    }, 500);
}

function blue() {
    $(document.getElementById('4')).addClass('blue-light');
    gameData.blueAudio.play();
    setTimeout(function() {
        $(document.getElementById('4')).removeClass('blue-light');
    }, 500);
}
</code></pre>

I later refactored the above into a single generic function. This enabled the removal of the audio from the gameData object also.
<pre><code>
function colour (colourAudio, id, className){
    $(document.getElementById(id)).addClass(className);
    colourAudio.play();
    setTimeout(function(){
     $(document.getElementById(id)).removeClass(className);  
    }, 500);
}
</code></pre>

The specs in the automated testing suite were then edited accordingly to test for the colour function being called.


## The player copies the game sequence - developing the playerInput function
Once the gameSequence has been displayed the player has to click on the coloured buttons in the same order as the sequence.<br>
The purpose of the playerInput function is to record the sequence of buttons the player clicks on.
#### Game Logic
1) Game has to recognise a player has clicked an option.<br>
I added event listeners to the playerInput function for a click on a coloured button like so:
<pre><code>
function playerInput() {
    document.getElementById('1').onclick = function() {
    // do something
    };
    document.getElementById('2').onclick = function() {
     // do something
    };
    document.getElementById('3').onclick = function() {
     //do something
    };
    document.getElementById('4').onclick = function() {
     // do something
    };
}
</code></pre>

2) Game has to connect that option with 1,2,3 or 4
3) That value has to be pushed into the playerSequence array

These clicks once noted by the game have to trigger an addition to the playerSequence array of the appropriate number:
<pre><code>
function playerInput() {
    document.getElementById('1').onclick = function() {
        gameData.playerSequence.push(1);
    };
    document.getElementById('2').onclick = function() {
        gameData.playerSequence.push(2);
    };
    document.getElementById('3').onclick = function() {
        gameData.playerSequence.push(3);
    };
    document.getElementById('4').onclick = function() {
        gameData.playerSequence.push(4);
    };
}
</code></pre>

#### User Interface
1) The player has to see/hear which option they have clicked - i.e square should light up and make sound.
To this end I added the same colour functions as used in the displaySequence function so the player experiences the same flash and sound.

<pre><code>
function playerInput() {
    document.getElementById('1').onclick = function() {
        gameData.playerSequence.push(1);
        red(); // causes red button to 'flash' and sound
    };
    document.getElementById('2').onclick = function() {
        gameData.playerSequence.push(2);
        yellow();
    };
    document.getElementById('3').onclick = function() {
        gameData.playerSequence.push(3);
        green();
    };
    document.getElementById('4').onclick = function() {
        gameData.playerSequence.push(4);
        blue();
    };
}
</code></pre>

## PlayerSequence is completed
The player must be able to click on squares UNTIL playerSequence length equals gameSequence length
#### Game Logic
1) PlayerInput function must be looped until the lengths are equal
2) Once the lengths are equal checkSequence function should be called.
I added a conditional to each event listener within playerInput which would cause it to loop through again if player hadn't yet pressed enough 
buttons OR call a new function, checkSequence.
<pre><code>
function playerInput() {
    document.getElementById('1').onclick = function() {
        gameData.playerSequence.push(1);
        red();
        if (gameData.playerSequence.length < gameData.gameSequence.length) { // player hasn't pushed enough buttons yet
            playerInput(); // triggers this function again
        }
        else { //player has pushed enough buttons
            checkSequence(); // playerSequence is passed to checkSequence function, game progresses
        }
    };
    document.getElementById('2').onclick = function() {
        gameData.playerSequence.push(2);
        yellow();
        if (gameData.playerSequence.length < gameData.gameSequence.length) {
            playerInput();
        }
        else {
            checkSequence();
        }
    };
    document.getElementById('3').onclick = function() {
        gameData.playerSequence.push(3);
        green();
        if (gameData.playerSequence.length < gameData.gameSequence.length) {
            playerInput();
        }
        else {
            checkSequence();
        }
    };
    document.getElementById('4').onclick = function() {
        gameData.playerSequence.push(4);
        blue();
        if (gameData.playerSequence.length < gameData.gameSequence.length) {
            playerInput();
        }
        else {
            checkSequence();
        }
    };
}
</code></pre>


## PlayerSequence is checked against gameSequence
The sequences must be equal for game to progress

#### Game Logic
1) checkSequence function needs to compare the two arrays (playersequence and gameSequence)
2) If they are equal but not 20 numbers in length the game progresses up a round - newRound function must be called
3) If they are equal AND 20 numbers in length (i.e its the last round) - game must restart - newGame function should be called
4) If they are not equal - the gameSequence must be displayed again for the player if strict mode is OFF or newGame called if strict mode is ON

I used an if/else statement to meet the above criteria. Because the two arrays to be compared are arrays, I joined them first then compared them as strings.
<pre><code>
function checkSequence() {
    if (gameData.playerSequence.join("") === gameData.gameSequence.join("") && gameData.gameSequence.length < 20) {
        gameData.playerSequence = []; // this variable also needs to be cleared before the next round
        newRound;
    }
    else if (gameData.playerSequence.join("") === gameData.gameSequence.join("") && gameData.gameSequence.length === 20) {
        newGame;
    }
    else {
        if (gameData.strictStatus === true) {
            newGame;
        }
        else {
            showSequence;
        }
    }
}
</code></pre>

5) playerSequence array must be cleared before next player input otherwise the arrays will never match.
<br> To clear this I added the code below to the displaySequence function - thus, everytime a sequence was displayed by the game, the player sequence was 
reset to empty ready for new player input.

<pre><code>
function displaySequence(i) {
    if (gameData.gameSequence[i] === 1) {
        red();
    }
    else if (gameData.gameSequence[i] === 2) {
        yellow();
    }
    else if (gameData.gameSequence[i] === 3) {
        green();
    }
    else {
        blue();
    }
    gameData.playerSequence = []; // player sequence reset to empty array
}
</code></pre>

#### User Interface
After the playerSequence is checked the player needs to see some visual indication of the result:
1) If sequence incorrect player should see "try again" message in display then see gameSequence repeated if strict mode OFF

I created a displayTryAgain function that changes the display content. This change remains in effect until newRound is called when displayCount will be called.
<pre><code>
function displayTryAgain() {
    document.getElementById('display').innerHTML = 'Try again!';
}
</code></pre>

2) If correct but not the final round player should see count increase in display and a new sequence (one item longer)
3) If correct and final round player should see 'win' message then re-start game

I created a displayWin function that changes the display content. This change remains in effect until newGame is called, which then calls newRound which then calls displayCount.
<pre><code>
function displayWin() {
    document.getElementById('display').innerHTML = 'Win!';
}
</code></pre>
4) If incorrect and game in strict mode, start again message should display before game re-starts.

I created the displayStartAgain function to indicate to the player they have to re-start the game.
This change remains in effect until newGame is called, which then calls newRound which then calls displayCount.
<pre><code>
function displayStartAgain(){
    document.getElementById('display').innerHTML = 'Start again!';
}
</code></pre>

5) To give the player time to see these messages there should be a delay before newGame or showSequence functions are shown respectively.
6) When moving to a newRound there should be a delay so player input and new sequence aren't displayed one straight after the other

I added timeouts and the display functions described above to the checkSequence function as follows, this provides a much better visual experience for the player:

<pre><code>
function checkSequence() {
    if (gameData.playerSequence.join("") === gameData.gameSequence.join("") && gameData.gameSequence.length < 20) {
        gameData.playerSequence = [];
        setTimeout(newRound, 1000);
    }
    else if (gameData.playerSequence.join("") === gameData.gameSequence.join("") && gameData.gameSequence.length === 20) {
        displayWin();
        setTimeout(newGame, 1000);
    }
    else {
        if (gameData.strictStatus === true) {
            displayStartAgain();
            setTimeout(newGame, 3000);
        }
        else {
            displayTryAgain();
            setTimeout(showSequence, 1000);
        }
    }
}
</code></pre>

## The player turns the game off
When the power button is in OFF mode colored buttons should not be able to be clicked.
#### Game Logic
1) When power button is set to off mode, and player presses on a colored button nothing should happen
i.e the color functions which are triggered during player input should NOT be called.

To achieve this I simply modified by power onclick function like so:
<pre><code>
document.getElementById('power').onclick = function() {
    gameData.powerStatus = !gameData.powerStatus;
    if (gameData.powerStatus === false) {
        gameData.startStatus = false;
        document.getElementById('1').onclick = function() {}; // these lines here mean if power is off and coloured buttons
        document.getElementById('2').onclick = function() {}; // are clicked - nothing is triggered - the function contains nothing 
        document.getElementById('3').onclick = function() {}; // so nothing is done.
        document.getElementById('4').onclick = function() {};
    }
};
</code></pre>

## Picked up during initial manual testing and from user feedback
4) Player should only be able to click the board while adding to playerSequence and not at any other, otherwise the sequence may not display correctly to the player.<br>
To achieve this I had to stop the colour functions being called whilst the player input function was not active.<br>
As with the power button above, I cleared the onclick functions for my coloured button ids. I did this within the showSequence function
because it needed to happen before the next game sequence was displayed (i.e display sequence was called).

<pre><code>
function showSequence() {
    document.getElementById('1').onclick = function() {};
    document.getElementById('2').onclick = function() {};
    document.getElementById('3').onclick = function() {};
    document.getElementById('4').onclick = function() {};
    var i = 0;
    let sequence = setInterval(function() {
        gameData.clickable = false;
        displaySequence(i);
        i++;
        if (i >= gameData.gameSequence.length) {
            clearInterval(sequence);
            playerInput();
        }
    }, 1000);
}
</code></pre>

The coloured buttons would then become clickable again once playerInput was called.
